; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list -c --asm --interleave -o.\obj\stm32f10x_cec.o --asm_dir=.\LST\ --list_dir=.\LST\ --depend=.\obj\stm32f10x_cec.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\HAL -I..\HAL\STM32F10x_FWLib\inc -I..\Drivers -I..\Applications\IAP -I..\Applications\SYSTEM -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=539 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\stm32f10x_cec.crf ..\HAL\STM32F10x_FWLib\src\stm32f10x_cec.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CEC_DeInit PROC
;;;117      */
;;;118    void CEC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120      /* Enable CEC reset state */
;;;121      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);  
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;122      /* Release CEC from reset state */
;;;123      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE); 
00000a  2100              MOVS     r1,#0
00000c  f04f4080          MOV      r0,#0x40000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;124    }
000014  bd10              POP      {r4,pc}
;;;125    
                          ENDP

                  CEC_Init PROC
;;;134      */
;;;135    void CEC_Init(CEC_InitTypeDef* CEC_InitStruct)
000016  2100              MOVS     r1,#0
;;;136    {
;;;137      uint16_t tmpreg = 0;
;;;138     
;;;139      /* Check the parameters */
;;;140      assert_param(IS_CEC_BIT_TIMING_ERROR_MODE(CEC_InitStruct->CEC_BitTimingMode)); 
;;;141      assert_param(IS_CEC_BIT_PERIOD_ERROR_MODE(CEC_InitStruct->CEC_BitPeriodMode));
;;;142         
;;;143      /*---------------------------- CEC CFGR Configuration -----------------*/
;;;144      /* Get the CEC CFGR value */
;;;145      tmpreg = CEC->CFGR;
000018  4a3e              LDR      r2,|L1.276|
00001a  6812              LDR      r2,[r2,#0]
00001c  b291              UXTH     r1,r2
;;;146      
;;;147      /* Clear BTEM and BPEM bits */
;;;148      tmpreg &= CFGR_CLEAR_Mask;
00001e  f00101f3          AND      r1,r1,#0xf3
;;;149      
;;;150      /* Configure CEC: Bit Timing Error and Bit Period Error */
;;;151      tmpreg |= (uint16_t)(CEC_InitStruct->CEC_BitTimingMode | CEC_InitStruct->CEC_BitPeriodMode);
000022  8802              LDRH     r2,[r0,#0]
000024  8843              LDRH     r3,[r0,#2]
000026  431a              ORRS     r2,r2,r3
000028  4311              ORRS     r1,r1,r2
;;;152    
;;;153      /* Write to CEC CFGR  register*/
;;;154      CEC->CFGR = tmpreg;
00002a  4a3a              LDR      r2,|L1.276|
00002c  6011              STR      r1,[r2,#0]
;;;155      
;;;156    }
00002e  4770              BX       lr
;;;157    
                          ENDP

                  CEC_Cmd PROC
;;;163      */
;;;164    void CEC_Cmd(FunctionalState NewState)
000030  4939              LDR      r1,|L1.280|
;;;165    {
;;;166      /* Check the parameters */
;;;167      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;168    
;;;169      *(__IO uint32_t *) CFGR_PE_BB = (uint32_t)NewState;
000032  6008              STR      r0,[r1,#0]
;;;170    
;;;171      if(NewState == DISABLE)
000034  b930              CBNZ     r0,|L1.68|
;;;172      {
;;;173        /* Wait until the PE bit is cleared by hardware (Idle Line detected) */
;;;174        while((CEC->CFGR & CEC_CFGR_PE) != (uint32_t)RESET)
000036  bf00              NOP      
                  |L1.56|
000038  4936              LDR      r1,|L1.276|
00003a  6809              LDR      r1,[r1,#0]
00003c  f0010101          AND      r1,r1,#1
000040  2900              CMP      r1,#0
000042  d1f9              BNE      |L1.56|
                  |L1.68|
;;;175        {
;;;176        }  
;;;177      }  
;;;178    }
000044  4770              BX       lr
;;;179    
                          ENDP

                  CEC_ITConfig PROC
;;;185      */
;;;186    void CEC_ITConfig(FunctionalState NewState)
000046  4934              LDR      r1,|L1.280|
;;;187    {
;;;188      /* Check the parameters */
;;;189      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;190    
;;;191      *(__IO uint32_t *) CFGR_IE_BB = (uint32_t)NewState;
000048  6048              STR      r0,[r1,#4]
;;;192    }
00004a  4770              BX       lr
;;;193    
                          ENDP

                  CEC_OwnAddressConfig PROC
;;;198      */
;;;199    void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)
00004c  4931              LDR      r1,|L1.276|
;;;200    {
;;;201      /* Check the parameters */
;;;202      assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));
;;;203    
;;;204      /* Set the CEC own address */
;;;205      CEC->OAR = CEC_OwnAddress;
00004e  1d09              ADDS     r1,r1,#4
000050  6008              STR      r0,[r1,#0]
;;;206    }
000052  4770              BX       lr
;;;207    
                          ENDP

                  CEC_SetPrescaler PROC
;;;212      */
;;;213    void CEC_SetPrescaler(uint16_t CEC_Prescaler)
000054  492f              LDR      r1,|L1.276|
;;;214    {
;;;215      /* Check the parameters */
;;;216      assert_param(IS_CEC_PRESCALER(CEC_Prescaler));
;;;217    
;;;218      /* Set the  Prescaler value*/
;;;219      CEC->PRES = CEC_Prescaler;
000056  3108              ADDS     r1,r1,#8
000058  6008              STR      r0,[r1,#0]
;;;220    }
00005a  4770              BX       lr
;;;221    
                          ENDP

                  CEC_SendDataByte PROC
;;;226      */
;;;227    void CEC_SendDataByte(uint8_t Data)
00005c  492d              LDR      r1,|L1.276|
;;;228    {  
;;;229      /* Transmit Data */
;;;230      CEC->TXD = Data ;
00005e  3114              ADDS     r1,r1,#0x14
000060  6008              STR      r0,[r1,#0]
;;;231    }
000062  4770              BX       lr
;;;232    
                          ENDP

                  CEC_ReceiveDataByte PROC
;;;238      */
;;;239    uint8_t CEC_ReceiveDataByte(void)
000064  482b              LDR      r0,|L1.276|
;;;240    {
;;;241      /* Receive Data */
;;;242      return (uint8_t)(CEC->RXD);
000066  3018              ADDS     r0,r0,#0x18
000068  6800              LDR      r0,[r0,#0]
00006a  b2c0              UXTB     r0,r0
;;;243    }
00006c  4770              BX       lr
;;;244    
                          ENDP

                  CEC_StartOfMessage PROC
;;;249      */
;;;250    void CEC_StartOfMessage(void)
00006e  2001              MOVS     r0,#1
;;;251    {  
;;;252      /* Starts of new message */
;;;253      *(__IO uint32_t *) CSR_TSOM_BB = (uint32_t)0x1;
000070  492a              LDR      r1,|L1.284|
000072  6008              STR      r0,[r1,#0]
;;;254    }
000074  4770              BX       lr
;;;255    
                          ENDP

                  CEC_EndOfMessageCmd PROC
;;;261      */
;;;262    void CEC_EndOfMessageCmd(FunctionalState NewState)
000076  4929              LDR      r1,|L1.284|
;;;263    {   
;;;264      /* Check the parameters */
;;;265      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;266      
;;;267      /* The data byte will be transmitted with or without an EOM bit*/
;;;268      *(__IO uint32_t *) CSR_TEOM_BB = (uint32_t)NewState;
000078  1d09              ADDS     r1,r1,#4
00007a  6008              STR      r0,[r1,#0]
;;;269    }
00007c  4770              BX       lr
;;;270    
                          ENDP

                  CEC_GetFlagStatus PROC
;;;290      */
;;;291    FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG) 
00007e  b510              PUSH     {r4,lr}
;;;292    {
000080  4601              MOV      r1,r0
;;;293      FlagStatus bitstatus = RESET;
000082  2000              MOVS     r0,#0
;;;294      uint32_t cecreg = 0, cecbase = 0;
000084  2300              MOVS     r3,#0
000086  2200              MOVS     r2,#0
;;;295      
;;;296      /* Check the parameters */
;;;297      assert_param(IS_CEC_GET_FLAG(CEC_FLAG));
;;;298     
;;;299      /* Get the CEC peripheral base address */
;;;300      cecbase = (uint32_t)(CEC_BASE);
000088  4a22              LDR      r2,|L1.276|
;;;301      
;;;302      /* Read flag register index */
;;;303      cecreg = CEC_FLAG >> 28;
00008a  0f0b              LSRS     r3,r1,#28
;;;304      
;;;305      /* Get bit[23:0] of the flag */
;;;306      CEC_FLAG &= FLAG_Mask;
00008c  f021417f          BIC      r1,r1,#0xff000000
;;;307      
;;;308      if(cecreg != 0)
000090  b113              CBZ      r3,|L1.152|
;;;309      {
;;;310        /* Flag in CEC ESR Register */
;;;311        CEC_FLAG = (uint32_t)(CEC_FLAG >> 16);
000092  0c09              LSRS     r1,r1,#16
;;;312        
;;;313        /* Get the CEC ESR register address */
;;;314        cecbase += 0xC;
000094  320c              ADDS     r2,r2,#0xc
000096  e000              B        |L1.154|
                  |L1.152|
;;;315      }
;;;316      else
;;;317      {
;;;318        /* Get the CEC CSR register address */
;;;319        cecbase += 0x10;
000098  3210              ADDS     r2,r2,#0x10
                  |L1.154|
;;;320      }
;;;321      
;;;322      if(((*(__IO uint32_t *)cecbase) & CEC_FLAG) != (uint32_t)RESET)
00009a  6814              LDR      r4,[r2,#0]
00009c  400c              ANDS     r4,r4,r1
00009e  b10c              CBZ      r4,|L1.164|
;;;323      {
;;;324        /* CEC_FLAG is set */
;;;325        bitstatus = SET;
0000a0  2001              MOVS     r0,#1
0000a2  e000              B        |L1.166|
                  |L1.164|
;;;326      }
;;;327      else
;;;328      {
;;;329        /* CEC_FLAG is reset */
;;;330        bitstatus = RESET;
0000a4  2000              MOVS     r0,#0
                  |L1.166|
;;;331      }
;;;332      
;;;333      /* Return the CEC_FLAG status */
;;;334      return  bitstatus;
;;;335    }
0000a6  bd10              POP      {r4,pc}
;;;336    
                          ENDP

                  CEC_ClearFlag PROC
;;;348      */
;;;349    void CEC_ClearFlag(uint32_t CEC_FLAG)
0000a8  2100              MOVS     r1,#0
;;;350    { 
;;;351      uint32_t tmp = 0x0;
;;;352      
;;;353      /* Check the parameters */
;;;354      assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));
;;;355    
;;;356      tmp = CEC->CSR & 0x2;
0000aa  4a1a              LDR      r2,|L1.276|
0000ac  3210              ADDS     r2,r2,#0x10
0000ae  6812              LDR      r2,[r2,#0]
0000b0  f0020102          AND      r1,r2,#2
;;;357           
;;;358      /* Clear the selected CEC flags */
;;;359      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_FLAG) & 0xFFFFFFFC) | tmp);
0000b4  4a17              LDR      r2,|L1.276|
0000b6  3210              ADDS     r2,r2,#0x10
0000b8  6813              LDR      r3,[r2,#0]
0000ba  f06f0203          MVN      r2,#3
0000be  4382              BICS     r2,r2,r0
0000c0  430a              ORRS     r2,r2,r1
0000c2  4013              ANDS     r3,r3,r2
0000c4  4a13              LDR      r2,|L1.276|
0000c6  3210              ADDS     r2,r2,#0x10
0000c8  6013              STR      r3,[r2,#0]
;;;360    }
0000ca  4770              BX       lr
;;;361    
                          ENDP

                  CEC_GetITStatus PROC
;;;371      */
;;;372    ITStatus CEC_GetITStatus(uint8_t CEC_IT)
0000cc  4601              MOV      r1,r0
;;;373    {
;;;374      ITStatus bitstatus = RESET;
0000ce  2000              MOVS     r0,#0
;;;375      uint32_t enablestatus = 0;
0000d0  2200              MOVS     r2,#0
;;;376      
;;;377      /* Check the parameters */
;;;378       assert_param(IS_CEC_GET_IT(CEC_IT));
;;;379       
;;;380      /* Get the CEC IT enable bit status */
;;;381      enablestatus = (CEC->CFGR & (uint8_t)CEC_CFGR_IE) ;
0000d2  4b10              LDR      r3,|L1.276|
0000d4  681b              LDR      r3,[r3,#0]
0000d6  f0030202          AND      r2,r3,#2
;;;382      
;;;383      /* Check the status of the specified CEC interrupt */
;;;384      if (((CEC->CSR & CEC_IT) != (uint32_t)RESET) && enablestatus)
0000da  4b0e              LDR      r3,|L1.276|
0000dc  3310              ADDS     r3,r3,#0x10
0000de  681b              LDR      r3,[r3,#0]
0000e0  400b              ANDS     r3,r3,r1
0000e2  b113              CBZ      r3,|L1.234|
0000e4  b10a              CBZ      r2,|L1.234|
;;;385      {
;;;386        /* CEC_IT is set */
;;;387        bitstatus = SET;
0000e6  2001              MOVS     r0,#1
0000e8  e000              B        |L1.236|
                  |L1.234|
;;;388      }
;;;389      else
;;;390      {
;;;391        /* CEC_IT is reset */
;;;392        bitstatus = RESET;
0000ea  2000              MOVS     r0,#0
                  |L1.236|
;;;393      }
;;;394      /* Return the CEC_IT status */
;;;395      return  bitstatus;
;;;396    }
0000ec  4770              BX       lr
;;;397    
                          ENDP

                  CEC_ClearITPendingBit PROC
;;;407      */
;;;408    void CEC_ClearITPendingBit(uint16_t CEC_IT)
0000ee  2100              MOVS     r1,#0
;;;409    {
;;;410      uint32_t tmp = 0x0;
;;;411      
;;;412      /* Check the parameters */
;;;413      assert_param(IS_CEC_GET_IT(CEC_IT));
;;;414      
;;;415      tmp = CEC->CSR & 0x2;
0000f0  4a08              LDR      r2,|L1.276|
0000f2  3210              ADDS     r2,r2,#0x10
0000f4  6812              LDR      r2,[r2,#0]
0000f6  f0020102          AND      r1,r2,#2
;;;416      
;;;417      /* Clear the selected CEC interrupt pending bits */
;;;418      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_IT) & 0xFFFFFFFC) | tmp);
0000fa  4a06              LDR      r2,|L1.276|
0000fc  3210              ADDS     r2,r2,#0x10
0000fe  6813              LDR      r3,[r2,#0]
000100  f06f0203          MVN      r2,#3
000104  4382              BICS     r2,r2,r0
000106  430a              ORRS     r2,r2,r1
000108  4013              ANDS     r3,r3,r2
00010a  4a02              LDR      r2,|L1.276|
00010c  3210              ADDS     r2,r2,#0x10
00010e  6013              STR      r3,[r2,#0]
;;;419    }
000110  4770              BX       lr
;;;420    
                          ENDP

000112  0000              DCW      0x0000
                  |L1.276|
                          DCD      0x40007800
                  |L1.280|
                          DCD      0x420f0000
                  |L1.284|
                          DCD      0x420f0200
