; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list -c --asm --interleave -o.\obj\usart.o --asm_dir=.\LST\ --list_dir=.\LST\ --depend=.\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\HAL -I..\HAL\STM32F10x_FWLib\inc -I..\Drivers -I..\Applications\IAP -I..\Applications\SYSTEM -ID:\Keil_v5\ARM\Packs\Keil\STM32F1xx_DFP\2.4.1\Device\Include -D__UVISION_VERSION=539 -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\usart.crf ..\Applications\SYSTEM\usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _sys_exit PROC
;;;47     //定义_sys_exit()以避免使用半主机模式    
;;;48     void _sys_exit(int x) 
000000  bf00              NOP      
;;;49     { 
;;;50     	x = x; 
;;;51     } 
000002  4770              BX       lr
;;;52     //重定义fputc函数 
                          ENDP

                  fputc PROC
;;;53     int fputc(int ch, FILE *f)
000004  bf00              NOP      
                  |L1.6|
;;;54     {      
;;;55     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000006  4a2c              LDR      r2,|L1.184|
000008  8812              LDRH     r2,[r2,#0]
00000a  f0020240          AND      r2,r2,#0x40
00000e  2a00              CMP      r2,#0
000010  d0f9              BEQ      |L1.6|
;;;56         USART1->DR = (u8) ch;      
000012  b2c2              UXTB     r2,r0
000014  4b28              LDR      r3,|L1.184|
000016  1d1b              ADDS     r3,r3,#4
000018  801a              STRH     r2,[r3,#0]
;;;57     	return ch;
;;;58     }
00001a  4770              BX       lr
;;;59     #endif 
                          ENDP

                  uart_init PROC
;;;89       
;;;90     void uart_init(u32 bound)
00001c  b510              PUSH     {r4,lr}
;;;91     {
00001e  b086              SUB      sp,sp,#0x18
000020  4604              MOV      r4,r0
;;;92     	//GPIO端口设置
;;;93     	GPIO_InitTypeDef GPIO_InitStructure;
;;;94     	USART_InitTypeDef USART_InitStructure;
;;;95     	NVIC_InitTypeDef NVIC_InitStructure;
;;;96     
;;;97     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000022  2101              MOVS     r1,#1
000024  f2440004          MOV      r0,#0x4004
000028  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;98     
;;;99     	//USART1_TX   GPIOA.9
;;;100    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
00002c  f44f7000          MOV      r0,#0x200
000030  f8ad0014          STRH     r0,[sp,#0x14]
;;;101    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000034  2003              MOVS     r0,#3
000036  f88d0016          STRB     r0,[sp,#0x16]
;;;102    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00003a  2018              MOVS     r0,#0x18
00003c  f88d0017          STRB     r0,[sp,#0x17]
;;;103    	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9
000040  a905              ADD      r1,sp,#0x14
000042  481e              LDR      r0,|L1.188|
000044  f7fffffe          BL       GPIO_Init
;;;104    
;;;105    	//USART1_RX	  GPIOA.10初始化
;;;106    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
000048  f44f6080          MOV      r0,#0x400
00004c  f8ad0014          STRH     r0,[sp,#0x14]
;;;107    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000050  2004              MOVS     r0,#4
000052  f88d0017          STRB     r0,[sp,#0x17]
;;;108    	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  
000056  a905              ADD      r1,sp,#0x14
000058  4818              LDR      r0,|L1.188|
00005a  f7fffffe          BL       GPIO_Init
;;;109    
;;;110    	//Usart1 NVIC 配置
;;;111    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00005e  2025              MOVS     r0,#0x25
000060  f88d0000          STRB     r0,[sp,#0]
;;;112    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3
000064  2003              MOVS     r0,#3
000066  f88d0001          STRB     r0,[sp,#1]
;;;113    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
00006a  f88d0002          STRB     r0,[sp,#2]
;;;114    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
00006e  2001              MOVS     r0,#1
000070  f88d0003          STRB     r0,[sp,#3]
;;;115    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
000074  4668              MOV      r0,sp
000076  f7fffffe          BL       NVIC_Init
;;;116    
;;;117    	//USART 初始化设置
;;;118    
;;;119    	USART_InitStructure.USART_BaudRate = bound;//串口波特率
00007a  9401              STR      r4,[sp,#4]
;;;120    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
00007c  2000              MOVS     r0,#0
00007e  f8ad0008          STRH     r0,[sp,#8]
;;;121    	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000082  f8ad000a          STRH     r0,[sp,#0xa]
;;;122    	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
000086  f8ad000c          STRH     r0,[sp,#0xc]
;;;123    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
00008a  f8ad0010          STRH     r0,[sp,#0x10]
;;;124    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
00008e  200c              MOVS     r0,#0xc
000090  f8ad000e          STRH     r0,[sp,#0xe]
;;;125    
;;;126    	USART_Init(USART1, &USART_InitStructure); //初始化串口1
000094  a901              ADD      r1,sp,#4
000096  4808              LDR      r0,|L1.184|
000098  f7fffffe          BL       USART_Init
;;;127    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
00009c  2201              MOVS     r2,#1
00009e  f2405125          MOV      r1,#0x525
0000a2  4805              LDR      r0,|L1.184|
0000a4  f7fffffe          BL       USART_ITConfig
;;;128    	USART_Cmd(USART1, ENABLE);                    //使能串口1 
0000a8  2101              MOVS     r1,#1
0000aa  4803              LDR      r0,|L1.184|
0000ac  f7fffffe          BL       USART_Cmd
;;;129    }
0000b0  b006              ADD      sp,sp,#0x18
0000b2  bd10              POP      {r4,pc}
;;;130    
                          ENDP

                  USART1_IRQHandler PROC
;;;131    void USART1_IRQHandler(void)
0000b4  4770              BX       lr
;;;132    {
;;;133    //	u8 res;	
;;;134    //#ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;135    //	OSIntEnter();    
;;;136    //#endif
;;;137    //	if(USART1->SR&(1<<5))//接收到数据
;;;138    //	{	 
;;;139    //		res=USART1->DR; 
;;;140    //		if(USART_RX_CNT<USART_REC_LEN)
;;;141    //		{
;;;142    //			USART_RX_BUF[USART_RX_CNT]=res;
;;;143    //			USART_RX_CNT++;			 									     
;;;144    //		}
;;;145    //	}
;;;146    //#ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;147    //	OSIntExit();  											 
;;;148    //#endif
;;;149    } 
;;;150    #endif	
                          ENDP

0000b6  0000              DCW      0x0000
                  |L1.184|
                          DCD      0x40013800
                  |L1.188|
                          DCD      0x40010800

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
